import { css as I, LitElement as C, html as b, svg as S } from "lit";
import { property as k, state as f, customElement as P, query as D } from "lit/decorators.js";
import { classMap as u } from "lit/directives/class-map.js";
import { a as Q, f as R, b as H, c as x, d as T, e as q, h as N, t as F, i as $ } from "./functions.697e57cd.js";
function d(y, e, t, i) {
  var s = arguments.length, r = s < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, n;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(y, e, t, i);
  else
    for (var a = y.length - 1; a >= 0; a--)
      (n = y[a]) && (r = (s < 3 ? n(r) : s > 3 ? n(e, t, r) : n(e, t)) || r);
  return s > 3 && r && Object.defineProperty(e, t, r), r;
}
class z {
  constructor(e, t) {
    this.runtime = e, this.canvas = t, this.disposed = !1, this.analyser = e.audioCtx.createAnalyser(), this.analyser.fftSize = 8192, this.analyser.smoothingTimeConstant = 0.5, e.connect(this.analyser), this.analysisData = new Uint8Array(this.analyser.frequencyBinCount);
    let i = Math.log10(e.audioCtx.sampleRate / 2) - 1;
    this.canvas.width = this.canvas.offsetWidth * window.devicePixelRatio, this.canvas.height = this.canvas.offsetHeight * window.devicePixelRatio, this.analysisXs = this.calculateAnalysisXs(i), this.resizeObserver = new ResizeObserver(() => {
      this.canvas.width = this.canvas.offsetWidth * window.devicePixelRatio, this.canvas.height = this.canvas.offsetHeight * window.devicePixelRatio, this.analysisXs = this.calculateAnalysisXs(i);
    }), this.resizeObserver.observe(this.canvas);
  }
  calculateAnalysisXs(e) {
    return Array.from(this.analysisData).map((t, i) => {
      let s = i / this.analysisData.length * (this.runtime.audioCtx.sampleRate / 2);
      return Math.floor((Math.log10(s) - 1) / e * this.canvas.width);
    });
  }
  analyse() {
    let e = () => {
      this.disposed || (this.analyser.getByteFrequencyData(this.analysisData), this.draw(), requestAnimationFrame(e));
    };
    requestAnimationFrame(e);
  }
  draw() {
    let e = this.canvas.width, t = this.canvas.height, i = this.canvas.height / 255, s = this.canvas.getContext("2d");
    if (!s)
      throw new Error("Could not get a canvas context!");
    s.clearRect(0, 0, e, t);
    let r = new Path2D();
    r.moveTo(0, t);
    for (let n = 0; n < this.analysisData.length; n++) {
      let a = Math.floor(t - this.analysisData[n] * i);
      r.lineTo(this.analysisXs[n], a);
    }
    r.lineTo(e, t), s.fillStyle = "rgba(30, 30, 60, 0.7)", s.fill(r), s.strokeStyle = "rgb(155, 155, 255)", s.stroke(r);
  }
  dispose() {
    this.disposed = !0, this.analyser.disconnect(), this.resizeObserver.disconnect();
  }
}
class E {
  constructor(e, t) {
    this.runtime = e, this.canvas = t, this.canvas.width = this.canvas.offsetWidth * window.devicePixelRatio, this.canvas.height = this.canvas.offsetHeight * window.devicePixelRatio, this.frequencies = this.calculateFrequencies(), this.filterMagResponse = new Float32Array(this.frequencies.length), this.filterPhaseResponse = new Float32Array(this.frequencies.length), this.frequencyResponse = new Float32Array(this.frequencies.length), this.resizeObserver = new ResizeObserver(() => {
      this.canvas.width = this.canvas.offsetWidth * window.devicePixelRatio, this.canvas.height = this.canvas.offsetHeight * window.devicePixelRatio, this.frequencies = this.calculateFrequencies(), this.filterMagResponse = new Float32Array(this.frequencies.length), this.filterPhaseResponse = new Float32Array(this.frequencies.length), this.frequencyResponse = new Float32Array(this.frequencies.length), this.render();
    }), this.resizeObserver.observe(this.canvas);
  }
  dispose() {
    this.resizeObserver.disconnect();
  }
  render() {
    this.frequencyResponse.fill(1);
    for (let e = 0; e < this.runtime.spec.length; e++)
      for (let t = 0; t < Q(this.runtime.spec[e].type); t++)
        if (this.runtime.getFrequencyResponse(e, t, this.frequencies, this.filterMagResponse, this.filterPhaseResponse))
          for (let s = 0; s < this.frequencyResponse.length; s++)
            this.frequencyResponse[s] *= this.filterMagResponse[s];
    this.draw();
  }
  draw() {
    let e = this.canvas.getContext("2d"), t = this.canvas.width, i = this.canvas.height;
    if (!e)
      throw new Error("Could not get a canvas context!");
    e.clearRect(0, 0, t, i), e.strokeStyle = "#ffffff", e.lineWidth = 2, e.beginPath();
    let s = 13, r = -s;
    for (let n = 0; n < this.frequencyResponse.length; n++) {
      let a = this.frequencyResponse[n], l = 20 * Math.log10(a), o = i - (l - r) / (s - r) * i;
      n === 0 ? e.moveTo(n, o) : e.lineTo(n, o);
    }
    e.stroke();
  }
  calculateFrequencies() {
    let e = new Float32Array(this.canvas.width), t = this.runtime.audioCtx.sampleRate / 2, i = 1, s = Math.log10(t);
    for (let r = 0; r < this.canvas.width; r++) {
      let n = i + r / this.canvas.width * (s - i), a = Math.pow(10, n);
      e[r] = a;
    }
    return e;
  }
}
const A = I`
  @import url("https://fonts.googleapis.com/css2?family=Inter:wght@500&display=swap");

  *,
  *::before,
  *::after {
    box-sizing: border-box;
  }

  :host {
    background-color: #111;
    color: white;
    --font-stack: "Inter", sans-serif;
    --font-size: 11px;
    --font-weight: 500;
    font-family: var(--font-stack);
    font-size: var(--font-size);
    font-weight: var(--font-weight);
  }
`, M = [
  ["noop", "Add +"],
  ["lowpass12", "LP12"],
  ["lowpass24", "LP24"],
  ["highpass12", "HP12"],
  ["highpass24", "HP24"],
  ["lowshelf12", "LS12"],
  ["lowshelf24", "LS24"],
  ["highshelf12", "HS12"],
  ["highshelf24", "HS24"],
  ["peaking12", "PK12"],
  ["peaking24", "PK24"],
  ["notch12", "NT12"],
  ["notch24", "NT24"]
];
var v;
let g = (v = class extends C {
  constructor() {
    super(), this.frequencyInputFocused = !1, this.dragStates = { frequency: null, gain: null, Q: null }, this.addEventListener("click", () => this.dispatchEvent(new CustomEvent("select", { composed: !0, bubbles: !0 })));
  }
  render() {
    if (!this.runtime || this.index === void 0)
      return;
    let e = M.filter((i) => this.runtime.supportedFilterTypes.includes(i[0])), t = this.runtime.spec[this.index];
    return b`
      <th>
        <div
          class=${u({
      chip: !0,
      disabled: !R(t.type),
      bypassed: t.bypass
    })}
        >
          <div
            class=${u({
      filterNumber: !0,
      bypassed: t.bypass
    })}
            @click=${() => this.toggleBypass()}
          >
            ${this.index + 1}
          </div>
          <select
            class=${u({ filterTypeSelect: !0, bypassed: t.bypass })}
            @change=${(i) => this.setFilterType(i.target.value)}
          >
            ${e.map(([i, s]) => b`<option value=${i} ?selected=${t.type === i}>
                  ${s}
                </option>`)}
          </select>
        </div>
      </th>
      <td>
        <input
          class=${u({
      frequencyInput: !0,
      numberInput: !0,
      bypassed: t.bypass
    })}
          type="number"
          step="0.1"
          lang="en_EN"
          .value=${H(t.frequency, this.frequencyInputFocused)}
          ?disabled=${!R(t.type)}
          @focus=${() => this.frequencyInputFocused = !0}
          @blur=${() => {
      this.frequencyInputFocused = !1, this.setFilterFrequency(x(t.frequency, 10, this.nyquist));
    }}
          @input=${(i) => this.setFilterFrequency(i.target.valueAsNumber)}
          @pointerdown=${(i) => this.startDraggingValue(i, "frequency")}
          @pointerup=${(i) => this.stopDraggingValue(i, "frequency")}
          @pointermove=${(i) => this.dragValue(i, "frequency")}
        />
        <span
          class=${u({
      frequencyUnit: !0,
      disabled: !R(t.type),
      bypassed: t.bypass
    })}
          >${T(t.frequency, this.frequencyInputFocused)}</span
        >
      </td>
      <td>
        <input
          class=${u({
      gainInput: !0,
      numberInput: !0,
      bypassed: t.bypass
    })}
          type="number"
          min="-15"
          max="15"
          step="0.1"
          lang="en_EN"
          .value=${t.gain.toFixed(1)}
          ?disabled=${!q(t.type)}
          @input=${(i) => this.setFilterGain(i.target.valueAsNumber)}
          @pointerdown=${(i) => this.startDraggingValue(i, "gain")}
          @pointerup=${(i) => this.stopDraggingValue(i, "gain")}
          @pointermove=${(i) => this.dragValue(i, "gain")}
        />
        <span
          class=${u({
      gainUnit: !0,
      disabled: !q(t.type),
      bypassed: t.bypass
    })}
          >dB</span
        >
      </td>
      <td>
        <input
          class=${u({
      qInput: !0,
      numberInput: !0,
      bypassed: t.bypass
    })}
          type="number"
          min="0.1"
          max="18"
          step="0.1"
          .value=${t.Q.toFixed(2)}
          ?disabled=${!N(t.type)}
          @input=${(i) => this.setFilterQ(i.target.valueAsNumber)}
          @pointerdown=${(i) => this.startDraggingValue(i, "Q")}
          @pointerup=${(i) => this.stopDraggingValue(i, "Q")}
          @pointermove=${(i) => this.dragValue(i, "Q")}
        />
      </td>
    `;
  }
  get nyquist() {
    var e, t;
    return ((t = (e = this.runtime) == null ? void 0 : e.audioCtx.sampleRate) != null ? t : 48e3) / 2;
  }
  toggleBypass() {
    !this.runtime || this.index === void 0 || this.runtime.toggleBypass(this.index, !this.runtime.spec[this.index].bypass);
  }
  setFilterType(e) {
    !this.runtime || this.index === void 0 || this.runtime.setFilterType(this.index, e);
  }
  setFilterFrequency(e) {
    !this.runtime || this.index === void 0 || isNaN(e) || this.runtime.setFilterFrequency(this.index, e);
  }
  setFilterGain(e) {
    !this.runtime || this.index === void 0 || isNaN(e) || this.runtime.setFilterGain(this.index, e);
  }
  setFilterQ(e) {
    !this.runtime || this.index === void 0 || isNaN(e) || this.runtime.setFilterQ(this.index, e);
  }
  startDraggingValue(e, t) {
    !this.runtime || this.index === void 0 || (e.target.setPointerCapture(e.pointerId), this.dragStates = {
      ...this.dragStates,
      [t]: {
        pointer: e.pointerId,
        startY: e.clientY,
        startValue: this.runtime.spec[this.index][t]
      }
    });
  }
  stopDraggingValue(e, t) {
    var i;
    !this.runtime || this.index === void 0 || ((i = this.dragStates[t]) == null ? void 0 : i.pointer) === e.pointerId && (e.target.releasePointerCapture(e.pointerId), this.dragStates = { ...this.dragStates, [t]: null });
  }
  dragValue(e, t) {
    if (!this.runtime || this.index === void 0)
      return;
    let i = this.dragStates[t];
    if (i && i.pointer === e.pointerId) {
      let s = i.startY, n = -(e.clientY - s), a = x(n / 150, -1, 1);
      if (t === "frequency") {
        let l = 10, o = this.runtime.audioCtx.sampleRate / 2, h = F(i.startValue, l, o), p = $(h + a, l, o);
        this.runtime.setFilterFrequency(this.index, p);
      } else if (t === "gain") {
        let l = a * 15;
        this.runtime.setFilterGain(this.index, x(i.startValue + l, -15, 15));
      } else if (t === "Q") {
        let l = 0.1, o = 18, h = F(i.startValue, l, o), p = $(h + a, l, o);
        this.runtime.setFilterQ(this.index, p);
      }
      e.target.blur();
    }
  }
}, (() => {
  v.styles = [
    A,
    I`
      :host {
        display: grid;
        grid-auto-flow: column;
        grid-template-columns: 60px 60px 50px 40px;
        align-items: center;
        gap: 4px;
        background-color: transparent;
        border-radius: 22px;
        transition: background-color 0.15s ease;
      }
      :host(.selected) {
        background-color: #373737;
      }
      input,
      select {
        padding: 0;
        border: 0;
      }
      input {
        border-bottom: 1px solid transparent;
        transition: border-color 0.15s ease;
      }
      input:focus,
      input:active {
        border-color: white;
      }
      .chip {
        display: inline-grid;
        grid-auto-flow: column;
        gap: 3px;
        height: 20px;
        padding-right: 6px;
        border-radius: 10px;
        background: #373737;
        transition: background-color 0.15s ease;
      }
      :host(.selected) .chip .filterNumber {
        background: #ffcc00;
      }
      .chip.disabled:hover {
        background: #444444;
      }
      .filterNumber {
        cursor: pointer;
        width: 20px;
        height: 20px;
        border-radius: 10px;
        display: grid;
        place-content: center;
        background: white;
        font-weight: var(--font-weight);
        color: black;
        transition: background-color 0.15s ease;
      }
      .chip.disabled .filterNumber {
        background: transparent;
        color: white;
      }
      .chip.bypassed .filterNumber {
        background: #7d7d7d;
        color: black;
      }
      .filterTypeSelect {
        width: 30px;
        appearance: none;
        outline: none;
        background-color: transparent;
        color: white;
        cursor: pointer;
        text-align: center;
        font-family: var(--font-stack);
        font-size: var(--font-size);
        font-weight: var(--font-weight);
      }
      .filterTypeSelect.bypassed {
        color: #7d7d7d;
      }
      .chip.disabled .filterTypeSelect {
        pointer-events: all;
      }
      .frequencyInput {
        width: 28px;
      }
      .gainInput {
        width: 26px;
      }
      .qInput {
        width: 30px;
      }
      .numberInput {
        appearance: none;
        outline: none;
        background-color: transparent;
        color: white;
        text-align: right;
        -moz-appearance: textfield;
        font-family: var(--font-stack);
        font-size: var(--font-size);
        font-weight: var(--font-weight);
        touch-action: none;
      }
      .numberInput:disabled,
      .disabled {
        color: #7d7d7d;
        pointer-events: none;
      }
      .bypassed {
        color: #7d7d7d;
      }
      .numberInput::-webkit-inner-spin-button,
      .numberInput::-webkit-outer-spin-button {
        -webkit-appearance: none !important;
        margin: 0 !important;
      }
    `
  ];
})(), v);
d([
  k({ attribute: !1 })
], g.prototype, "runtime", void 0);
d([
  k()
], g.prototype, "index", void 0);
d([
  f()
], g.prototype, "frequencyInputFocused", void 0);
d([
  f()
], g.prototype, "dragStates", void 0);
g = d([
  P("weq8-ui-filter-row")
], g);
var w;
let c = (w = class extends C {
  constructor() {
    super(), this.gridXs = [], this.dragStates = {}, this.selectedFilterIdx = -1, this.addEventListener("click", (e) => {
      e.composedPath()[0] === this && (this.selectedFilterIdx = -1);
    });
  }
  updated(e) {
    var t, i;
    if (e.has("runtime") && ((t = this.analyser) == null || t.dispose(), (i = this.frequencyResponse) == null || i.dispose(), this.runtime && this.analyserCanvas && this.frequencyResponseCanvas)) {
      this.analyser = new z(this.runtime, this.analyserCanvas), this.analyser.analyse(), this.frequencyResponse = new E(this.runtime, this.frequencyResponseCanvas), this.frequencyResponse.render();
      let s = [], r = this.runtime.audioCtx.sampleRate / 2, n = Math.floor(Math.log10(r));
      for (let a = 0; a < n; a++) {
        let l = Math.pow(10, a + 1);
        for (let o = 1; o < 10; o++) {
          let h = l * o;
          if (h > r)
            break;
          s.push((Math.log10(h) - 1) / (Math.log10(r) - 1) * 100);
        }
      }
      this.gridXs = s, this.runtime.on("filtersChanged", () => {
        var a, l, o;
        (a = this.frequencyResponse) == null || a.render(), this.requestUpdate();
        for (let h of Array.from((o = (l = this.shadowRoot) == null ? void 0 : l.querySelectorAll("weq8-ui-filter-row")) != null ? o : []))
          h.requestUpdate();
      });
    }
  }
  render() {
    var e;
    return b`
      <table class="filters">
        <thead>
          <tr>
            <th class="headerFilter">Filter</th>
            <th>Freq</th>
            <th>Gain</th>
            <th>Q</th>
          </tr>
        </thead>
        <tbody>
          ${Array.from({ length: 8 }).map((t, i) => b`<weq8-ui-filter-row
                class="${u({ selected: this.selectedFilterIdx === i })}"
                .runtime=${this.runtime}
                .index=${i}
                @select=${(s) => {
      var r;
      this.selectedFilterIdx = ((r = this.runtime) == null ? void 0 : r.spec[i].type) === "noop" ? -1 : i, s.stopPropagation();
    }}
              />`)}
        </tbody>
      </table>
      <div class="visualisation">
        <svg
          viewBox="0 0 100 10"
          preserveAspectRatio="none"
          xmlns="http://www.w3.org/2000/svg"
        >
          ${this.gridXs.map(this.renderGridX)}
          ${[12, 6, 0, -6, -12].map(this.renderGridY)}
        </svg>
        <canvas class="analyser"></canvas>
        <canvas
          class="frequencyResponse"
          @click=${() => this.selectedFilterIdx = -1}
        ></canvas>
        ${(e = this.runtime) == null ? void 0 : e.spec.map((t, i) => t.type === "noop" ? void 0 : this.renderFilterHandle(t, i))}
      </div>
    `;
  }
  renderGridX(e) {
    return S`<line
      class="grid-x"
      x1=${e}
      y1="0"
      x2=${e}
      y2="10"
    />`;
  }
  renderGridY(e) {
    let i = (e + 15) / 30 * 10;
    return S`<line
      class="grid-y"
      x1="0"
      y1=${i}
      x2="100"
      y2=${i}
    />`;
  }
  renderFilterHandle(e, t) {
    var l, o, h, p;
    if (!this.runtime)
      return;
    let i = this.runtime.spec[t].type, s = (o = (l = this.analyserCanvas) == null ? void 0 : l.offsetWidth) != null ? o : 0, r = (p = (h = this.analyserCanvas) == null ? void 0 : h.offsetHeight) != null ? p : 0, n = F(e.frequency, 10, this.runtime.audioCtx.sampleRate / 2) * s, a = r - (e.gain + 15) / 30 * r;
    return q(i) || (a = r - F(e.Q, 0.1, 18) * r), b`<div
      class="filter-handle-positioner"
      style="transform: translate(${n}px,${a}px)"
      @pointerdown=${(m) => this.startDraggingFilterHandle(m, t)}
      @pointerup=${(m) => this.stopDraggingFilterHandle(m, t)}
      @pointermove=${(m) => this.dragFilterHandle(m, t)}
    >
      <div
        class="${u({
      "filter-handle": !0,
      bypassed: e.bypass,
      selected: t === this.selectedFilterIdx
    })}"
      >
        ${t + 1}
      </div>
    </div>`;
  }
  startDraggingFilterHandle(e, t) {
    e.target.setPointerCapture(e.pointerId), this.dragStates = { ...this.dragStates, [t]: e.pointerId }, this.selectedFilterIdx = t, e.preventDefault();
  }
  stopDraggingFilterHandle(e, t) {
    this.dragStates[t] === e.pointerId && (e.target.releasePointerCapture(e.pointerId), this.dragStates = { ...this.dragStates, [t]: null });
  }
  dragFilterHandle(e, t) {
    var i, s;
    if (this.runtime && this.dragStates[t] === e.pointerId) {
      let r = this.runtime.spec[t].type, n = (s = (i = this.frequencyResponseCanvas) == null ? void 0 : i.getBoundingClientRect()) != null ? s : {
        left: 0,
        top: 0,
        width: 0,
        height: 0
      }, a = e.clientX - n.left, l = e.clientY - n.top, o = $(a / n.width, 10, this.runtime.audioCtx.sampleRate / 2);
      this.runtime.setFilterFrequency(t, o);
      let h = 1 - l / n.height;
      if (q(r)) {
        let p = x(h * 30 - 15, -15, 15);
        this.runtime.setFilterGain(t, p);
      } else {
        let p = $(h, 0.1, 18);
        this.runtime.setFilterQ(t, p);
      }
    }
  }
}, (() => {
  w.styles = [
    A,
    I`
      :host {
        display: flex;
        flex-direction: row;
        align-items: stretch;
        gap: 10px;
        min-width: 600px;
        min-height: 200px;
        padding: 20px;
        border-radius: 8px;
        overflow: hidden;
        background: #202020;
        border: 1px solid #373737;
      }
      .filters {
        display: inline-grid;
        grid-auto-flow: row;
        gap: 4px;
      }
      .filters tbody,
      .filters tr {
        display: contents;
      }
      .filters thead {
        display: grid;
        grid-auto-flow: column;
        grid-template-columns: 60px 60px 50px 40px;
        align-items: center;
        gap: 4px;
      }
      .filters thead th {
        display: grid;
        place-content: center;
        height: 20px;
        border-radius: 10px;
        font-weight: var(--font-weight);
        border: 1px solid #373737;
      }
      .filters thead th.headerFilter {
        text-align: left;
        padding-left: 18px;
        border: none;
      }
      .visualisation {
        flex: 1;
        position: relative;
        border: 1px solid #373737;
      }
      canvas,
      svg {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }
      svg {
        overflow: visible;
      }
      .grid-x,
      .grid-y {
        stroke: #333;
        stroke-width: 1;
        vector-effect: non-scaling-stroke;
      }
      .filter-handle-positioner {
        position: absolute;
        top: 0;
        left: 0;
        width: 30px;
        height: 30px;
        touch-action: none;
      }
      .filter-handle {
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background-color: #fff;
        color: black;
        transform: translate(-50%, -50%);
        display: flex;
        justify-content: center;
        align-items: center;
        user-select: none;
        cursor: grab;
        transition: background-color 0.15s ease;
      }
      .filter-handle.selected {
        background: #ffcc00;
      }
      .filter-handle.bypassed {
        background: #7d7d7d;
      }
    `
  ];
})(), w);
d([
  k({ attribute: !1 })
], c.prototype, "runtime", void 0);
d([
  f()
], c.prototype, "analyser", void 0);
d([
  f()
], c.prototype, "frequencyResponse", void 0);
d([
  f()
], c.prototype, "gridXs", void 0);
d([
  f()
], c.prototype, "dragStates", void 0);
d([
  f()
], c.prototype, "selectedFilterIdx", void 0);
d([
  D(".analyser")
], c.prototype, "analyserCanvas", void 0);
d([
  D(".frequencyResponse")
], c.prototype, "frequencyResponseCanvas", void 0);
c = d([
  P("weq8-ui")
], c);
export {
  c as WEQ8UIElement
};
